"""Code for problem 1 a) and b). 

a) Numerical solution using the given difference method in task 1a.

b) Modify code from a) with different boundary conditions.
In this case we have Dirichlet on both sides, which corresponds to 
the simple case example in 3.1 in BO's note.
"""
from scipy.interpolate import interp1d 
from scipy.integrate import quad
import numpy as np
import scipy.linalg as la
import matplotlib.pyplot as plt
import scipy.sparse.linalg as sla
import scipy.sparse as sp

def f(x):
    """Right hand side of 1D Poisson equation."""
    return np.cos(2*np.pi*x) + x

def anal_solution(x, alpha, sigma):
    """Analytical solution of the Possion equation with given Neumann BC.
    
    alpha = sigma = 0 gives solution from 1a).
    alpha = 1, sigma = 1/3 gives solution from 1b).
    """
    return -1/(4*np.pi**2)*np.cos(2*np.pi*x) + 1/6*x**3 + (sigma - 1/2)*x + alpha + 1/(4*np.pi**2)

def num_solution_a(x, M):
    """Numerical solution of the Possion equation with given Neumann BC in 1a)."""

    h = 1/(M+1)

    # Construct Ah. 
    data = np.array([np.full(M+1, 1), np.full(M+1, -2), np.full(M+1, 1)])
    diags = np.array([-1, 0, 1])
    Ah = sp.spdiags(data, diags, M+1, M+1).toarray()*1/h**2
    
    Ah[-1, -3] = h/2
    Ah[-1, -2] = -2*h
    Ah[-1, -1] = 3*h/2

    # Construct f.
    f_vec = np.full(M+1, f(x[1:]))
    f_vec[0] = f_vec[0] - 0/h**2
    f_vec[-1] = 0

    # Solve linear system. 
    Usol = la.solve(Ah, f_vec) # Ah is not sparse enough to yield an advantage when using sla.spsolve. 
    # Hence, the system is solved via la.solve instead. 
    # This is seen when using diags above and formatting into "csc": A SparseEfficiencyWarning is generated by Scipy. 

    # Add left Dirichlet condition to solution.
    Usol = np.insert(Usol, 0, 0)

    return Usol

def num_solution_b(x, M):
    """Numerical solution of the Possion equation with given Neumann BC in 1b)."""

    h = 1/(M+1)

    # Construct Ah. 
    data = np.array([np.full(M, 1), np.full(M, -2), np.full(M, 1)])
    diags = np.array([-1, 0, 1])
    Ah = sp.spdiags(data, diags, M, M).toarray()*1/h**2

    # Construct f.
    f_vec = np.full(M, f(x[1:-1]))
    f_vec[0] = f_vec[0] - 1/h**2
    f_vec[-1] = f_vec[-1] - 1/h**2

    # Solve linear system. 
    Usol = la.solve(Ah, f_vec) # Ah is not sparse enough to yield an advantage when using sla.spsolve. 
    # Hence, the system is solved via la.solve instead. 
    # This is seen when using diags above and formatting into "csc": A SparseEfficiencyWarning is generated by Scipy. 

    # Add left Dirichlet condition to solution.
    Usol = np.insert(Usol, 0, 1)

    # Add right Dirichlet condtion to solution.
    Usol = np.append(Usol, 1)

    return Usol

M = 40
x = np.linspace(0, 1, M+2) # Make 1D grid.

def plot_solutions(problem = "a", save = False):
    """Encapsulate the plotting of the solution under development for ease of use.
    
    Input: 
    problem: Problem 'a' or problem 'b'.
    save: Dictate if a pdf of the plot is saved or not. 
    """
    assert(problem == "a" or problem == "b")
    if problem == "a":
        plt.plot(x, anal_solution(x, alpha = 0, sigma = 0), label="An", color = "black", marker = "o", linewidth = 2)
        plt.plot(x, num_solution_a(x, M), label="Num", color = "red", linestyle = "dotted", marker = "o", linewidth = 3)
    else: 
        plt.plot(x, anal_solution(x, alpha = 1, sigma = 1/3), label="An", color = "black", marker = "o", linewidth = 2)
        plt.plot(x, num_solution_b(x, M), label="Num", color = "red", linestyle = "dotted", marker = "o", linewidth = 3)
    plt.xlabel(r"$x$")
    plt.ylabel(r"$u$")
    plt.legend()
    if save:
        if problem == "a":
            plt.savefig("solutionsTask1a.pdf")
        else: 
            plt.savefig("solutionsTask1b.pdf")
    plt.show()

#plot_solutions(problem = "b")

#----Make convergence plots for both norms---- 
# Consider if these functions can be matched with the more general ones that are in utilities.py
# once 1d is merged into master! These are different because of alpha and sigma...
# These arguments makes this a lot harder!

def e_l(U, u): # this can be deleted at least, since it will be the same as in utilities.py. Make sure that the functions in utilities.py also have asserts!
    """Relative error e_l.
    
    U: Approximate numerical solution.
    u: Analytical solution. 
    """
    assert(not callable(u) and not callable(U))
    return la.norm(u-U)/la.norm(u)

def cont_L2_norm(v, left, right, alpha, sigma):
    """Continuous L2 norm of v(x) between left and right. """
    assert(callable(v))
    integrand = lambda x, alpha, sigma: v(x, alpha, sigma)**2
    return np.sqrt(quad(integrand, left, right, args = (alpha, sigma))[0])

def e_L(U, u, left, right, alpha, sigma):
    """Relative error e_L.
    
    U: Approximate numerical solution.
    u: Function returning analytical solution. 
    """
    assert(callable(u) and callable(U))
    f = lambda x, alpha, sigma : u(x, alpha = alpha, sigma = sigma) - U(x)
    numer = cont_L2_norm(f, left, right, alpha = alpha, sigma = sigma)
    denom = cont_L2_norm(u, left, right, alpha = alpha, sigma = sigma)

    return numer/denom

def plot_convergence_plot(problem = "a", save = False):
    """Construct and plot convergence plot.
    
    Input: 
    problem: Problem 'a' or problem 'b'.
    save: Dictate if a pdf of the plot is saved or not.
    """
    assert(problem == "a" or problem == "b")
    M = np.arange(2, 1012/5, 10, dtype = int)
    discrete_error = np.zeros(len(M))
    cont_error = np.zeros(len(M))

    for i, m in enumerate(M):
        x = np.linspace(0, 1, m+2)
        if problem == "a":
            Usol = num_solution_a(x, M = m)
            analsol = anal_solution(x, alpha = 0, sigma = 0)
            interpU = interp1d(x, Usol, kind = 'cubic')
            cont_error[i] = e_L(interpU, anal_solution, x[0], x[-1], alpha = 0, sigma = 0)
        else: 
            Usol = num_solution_b(x, M = m)
            analsol = anal_solution(x, alpha = 1, sigma = 1/3)
            interpU = interp1d(x, Usol, kind = 'cubic')
            cont_error[i] = e_L(interpU, anal_solution, x[0], x[-1], alpha = 1, sigma = 1/3)
        
        discrete_error[i] = e_l(Usol, analsol)

    fig = plt.figure()
    ax = fig.add_subplot(111)
    ax.set_xscale("log")
    ax.set_yscale("log")
    ax.plot(M, discrete_error, label=r"$e^r_\ell$", color = "blue", marker = "o", linewidth = 3)
    ax.plot(M, cont_error, label = r"$e^r_{L_2}$", color = "red", linestyle = "--", marker = "o", linewidth = 2)
    ax.plot(M, (lambda x: 1/x**2)(M), label=r"$O$($h^2$)", color = "green", linewidth = 2)
    ax.set_ylabel(r"Error $e^r_{(\cdot)}$")
    ax.set_xlabel("Number of points M")
    plt.legend()
    plt.grid() 
    if save:
        if problem == "a":
            plt.savefig("loglogtask1a.pdf")
        else: 
            plt.savefig("loglogtask1b.pdf")
    plt.show() 

#plot_convergence_plot(problem = "a")
